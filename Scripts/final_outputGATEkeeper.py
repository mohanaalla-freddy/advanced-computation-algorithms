{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "09a1cdf4-8e80-4528-a985-3eb7d9bf9a1d",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "IOPub data rate exceeded.\n",
      "The Jupyter server will temporarily stop sending output\n",
      "to the client in order to avoid crashing it.\n",
      "To change this limit, set the config variable\n",
      "`--ServerApp.iopub_data_rate_limit`.\n",
      "\n",
      "Current values:\n",
      "ServerApp.iopub_data_rate_limit=1000000.0 (bytes/sec)\n",
      "ServerApp.rate_limit_window=3.0 (secs)\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Adjacency matrix saved to /Users/mohanavenkataphaneendrareddyalla/Desktop/newtrail_adjacency_matrix.csv\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "def read_mutation_file(mutation_file, genome1, genome2, adjacency_matrix):\n",
    "    \"\"\"Reads the mutation count from the specified file and updates the adjacency matrix.\"\"\"\n",
    "    print(f\"Checking for mutation file: {mutation_file}\")  # Debugging statement\n",
    "    if os.path.exists(mutation_file):\n",
    "        with open(mutation_file, 'r') as f:\n",
    "            try:\n",
    "                mutations = int(f.readline().strip())  # Read the number of mutations from the file\n",
    "                index1 = int(genome1.split('_')[1]) - 1  # Extract index from genome name\n",
    "                index2 = int(genome2.split('_')[1]) - 1\n",
    "                adjacency_matrix[index1, index2] = mutations\n",
    "                adjacency_matrix[index2, index1] = mutations  # Symmetric matrix\n",
    "                print(f\"Mutations between {genome1} and {genome2}: {mutations}\")  # Debugging statement\n",
    "            except ValueError:\n",
    "                print(f\"Error reading mutation count from {mutation_file}.\")  # Debugging statement\n",
    "    else:\n",
    "        print(f\"Mutation file not found: {mutation_file}\")  # Debugging statement\n",
    "\n",
    "\n",
    "def compute_adjacency_matrix(genome_files, output_prefix):\n",
    "    \"\"\"Computes the adjacency matrix based on mutation files.\"\"\"\n",
    "    num_genomes = len(genome_files)\n",
    "    adjacency_matrix = np.zeros((num_genomes, num_genomes), dtype=int)\n",
    "\n",
    "    for i in range(num_genomes):\n",
    "        for j in range(i + 1, num_genomes):\n",
    "            genome1 = genome_files[i]\n",
    "            genome2 = genome_files[j]\n",
    "            mutation_file = f\"{output_prefix}_{genome1.split('.')[0]}_{genome2.split('.')[0]}.mutations\"  # Adjust based on actual output file naming convention\n",
    "            read_mutation_file(mutation_file, genome1, genome2, adjacency_matrix)\n",
    "\n",
    "    return adjacency_matrix\n",
    "\n",
    "\n",
    "def save_adjacency_matrix(adjacency_matrix, genome_files, output_csv_path):\n",
    "    \"\"\"Saves the adjacency matrix to a CSV file.\"\"\"\n",
    "    adjacency_df = pd.DataFrame(adjacency_matrix, index=genome_files, columns=genome_files)\n",
    "    adjacency_df.to_csv(output_csv_path)\n",
    "    print(f\"Adjacency matrix saved to {output_csv_path}\")\n",
    "\n",
    "\n",
    "# Directory containing the mutation files\n",
    "vcf_directory = '/Users/mohanavenkataphaneendrareddyalla/Desktop/trail_alignment_results'\n",
    "output_prefix = 'Users/mohanavenkataphaneendrareddyalla/Desktop/trail_mutation'  # Adjust this based on your actual output prefix\n",
    "\n",
    "# List all genome files (assumed to be in a specific format)\n",
    "genome_files = [f for f in os.listdir(vcf_directory) if f.endswith('.vcf')]\n",
    "\n",
    "if not genome_files:\n",
    "    print(\"No genome files found in the specified directory.\")\n",
    "else:\n",
    "    # Compute the adjacency matrix\n",
    "    adjacency_matrix = compute_adjacency_matrix(genome_files, output_prefix)\n",
    "\n",
    "    # Save the adjacency matrix to a file\n",
    "    output_csv_path = '/Users/mohanavenkataphaneendrareddyalla/Desktop/newtrail_adjacency_matrix.csv'\n",
    "    save_adjacency_matrix(adjacency_matrix, genome_files, output_csv_path)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "3dee1ba0-9ce7-4f11-b69b-ab27c4950a1d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mutation matrix saved to /Users/mohanavenkataphaneendrareddyalla/Desktop/check_mutation_matrix_with_labels.csv\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "import csv\n",
    "\n",
    "def parse_vcf(vcf_file):\n",
    "    \"\"\"Parses a VCF file and returns a set of mutation positions.\"\"\"\n",
    "    mutations = set()\n",
    "    with open(vcf_file, 'r') as file:\n",
    "        for line in file:\n",
    "            if line.startswith('#'):\n",
    "                continue  # Skip header lines\n",
    "            fields = line.strip().split('\\t')\n",
    "            chrom, pos, ref, alt = fields[0], int(fields[1]), fields[3], fields[4]\n",
    "            # Store mutation as a tuple (chromosome, position, reference, alternate)\n",
    "            mutation = (chrom, pos, ref, alt)\n",
    "            mutations.add(mutation)\n",
    "    return mutations\n",
    "\n",
    "def compute_mutation_matrix(genome_files):\n",
    "    \"\"\"Computes the adjacency matrix for the given genome files.\"\"\"\n",
    "    num_genomes = len(genome_files)\n",
    "    mutation_matrix = np.zeros((num_genomes, num_genomes), dtype=int)\n",
    "\n",
    "    # Parse VCF files and store mutation sets\n",
    "    mutation_sets = [parse_vcf(vcf_file) for vcf_file in genome_files]\n",
    "\n",
    "    # Compare each pair of genomes to calculate mutation differences\n",
    "    for i in range(num_genomes):\n",
    "        for j in range(i + 1, num_genomes):\n",
    "            # Count differences in mutation sets using symmetric difference\n",
    "            mutation_diff = len(mutation_sets[i].symmetric_difference(mutation_sets[j]))\n",
    "            # Update adjacency matrix (symmetric)\n",
    "            mutation_matrix[i, j] = mutation_diff\n",
    "            mutation_matrix[j, i] = mutation_diff\n",
    "\n",
    "    return mutation_matrix\n",
    "\n",
    "def save_mutation_matrix_with_labels(mutation_matrix, genome_files, output_file):\n",
    "    \"\"\"Saves the mutation matrix to a CSV file with genome file names as headings.\"\"\"\n",
    "    # Extract file names without the directory and extension\n",
    "    genome_labels = [os.path.splitext(os.path.basename(f))[0] for f in genome_files]\n",
    "\n",
    "    # Write the matrix to a CSV file with labels\n",
    "    with open(output_file, 'w', newline='') as file:\n",
    "        writer = csv.writer(file)\n",
    "        # Write the header row\n",
    "        writer.writerow([\"\"] + genome_labels)\n",
    "        # Write each row with a label\n",
    "        for label, row in zip(genome_labels, mutation_matrix):\n",
    "            writer.writerow([label] + list(row))\n",
    "\n",
    "# Directory containing the 100 VCF files\n",
    "vcf_directory = '/Users/mohanavenkataphaneendrareddyalla/Desktop/trail_alignment_results'\n",
    "\n",
    "# List all VCF files in the directory\n",
    "genome_files = [os.path.join(vcf_directory, f) for f in os.listdir(vcf_directory) if f.endswith('.vcf')]\n",
    "\n",
    "# Compute the mutation matrix\n",
    "mutation_matrix = compute_mutation_matrix(genome_files)\n",
    "\n",
    "# Save the mutation matrix to a file with labels\n",
    "output_file = '/Users/mohanavenkataphaneendrareddyalla/Desktop/check_mutation_matrix_with_labels.csv'\n",
    "save_mutation_matrix_with_labels(mutation_matrix, genome_files, output_file)\n",
    "\n",
    "print(f\"Mutation matrix saved to {output_file}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dba9918d-2e03-493b-9d3f-6a481da40e8f",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
